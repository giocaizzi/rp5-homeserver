// =============================================================================
// LOGS PIPELINE MODULE
// =============================================================================
// Collects logs from Docker containers via the Docker socket, applies
// OTEL-aligned labels, and ships to Loki.
//
// Data Flow:
//   Docker Discovery → Label Extraction → Log Collection → Processing → Loki
//   (nginx logs routed to dedicated nginx_logs module for structured parsing)
//
// Arguments:
//   docker_labels_output - Targets from docker_labels module
//   docker_labels_rules  - Relabel rules from docker_labels module
//   loki_receiver        - Loki write endpoint receiver
//   nginx_logs_receiver  - Receiver from nginx_logs module for nginx-specific parsing
// =============================================================================

declare "docker_logs" {
  // ---------------------------------------------------------------------------
  // ARGUMENTS
  // ---------------------------------------------------------------------------
  argument "docker_labels_output" {
    comment = "Targets from docker_labels module"
  }

  argument "docker_labels_rules" {
    comment = "Relabel rules from docker_labels module"
  }

  argument "loki_receiver" {
    comment = "Loki write endpoint receiver"
  }

  argument "nginx_logs_receiver" {
    comment = "Receiver from nginx_logs module for nginx-specific parsing"
  }

  // ---------------------------------------------------------------------------
  // LOG TARGETS FROM DOCKER DISCOVERY
  // ---------------------------------------------------------------------------
  // Uses shared discovery, applies label extraction module

  discovery.relabel "logs" {
    targets = argument.docker_labels_output.value

    // Drop containers without namespace (external/unmanaged)
    rule {
      source_labels = ["service_namespace"]
      regex         = "external"
      action        = "drop"
    }

    // Keep only our labeled containers
    rule {
      source_labels = ["__meta_docker_container_label_com_giocaizzi_namespace"]
      regex         = ".+"
      action        = "keep"
    }
  }

  // ---------------------------------------------------------------------------
  // DOCKER LOG COLLECTION
  // ---------------------------------------------------------------------------
  // Reads logs from container log files via Docker socket
  // Routes to pre-processor for Docker parsing and label extraction

  loki.source.docker "logs" {
    host             = "unix:///var/run/docker.sock"
    targets          = discovery.relabel.logs.output
    forward_to       = [loki.process.preprocess.receiver]
    refresh_interval = "5s"
    relabel_rules    = argument.docker_labels_rules.value
  }

  // ---------------------------------------------------------------------------
  // LOG PREPROCESSING
  // ---------------------------------------------------------------------------
  // Common Docker log parsing and label extraction for all containers.
  // Routes to technology-specific processors after preprocessing.

  loki.process "preprocess" {
    // Fan out to both processors - each will filter by technology
    forward_to = [loki.process.nginx.receiver, loki.process.generic.receiver]

    // Docker-specific log parsing
    stage.docker {}

    // Add source label
    stage.static_labels {
      values = {
        source = "docker",
      }
    }

    // Promote existing labels (from relabel_rules)
    stage.label_keep {
      values = [
        "service_name",
        "service_namespace",
        "deployment_environment_name",
        "tier",
        "component",
        "technology",
        "host_name",
        "source",
      ]
    }

    // Drop high-cardinality Docker metadata
    stage.label_drop {
      values = [
        "filename",
        "service_instance_id",
        "service_version",
      ]
    }
  }

  // ---------------------------------------------------------------------------
  // NGINX LOG PROCESSING
  // ---------------------------------------------------------------------------
  // Routes nginx logs to dedicated nginx_logs module for structured parsing
  // Drops non-nginx logs; keeps only technology="nginx" for forwarding

  loki.process "nginx" {
    forward_to = argument.nginx_logs_receiver.value

    // Drop non-nginx logs (only nginx logs pass through to nginx_logs module)
    stage.match {
      selector = "{technology!=\"nginx\"}"
      action   = "drop"
    }
  }

  // ---------------------------------------------------------------------------
  // GENERIC LOG PROCESSING
  // ---------------------------------------------------------------------------
  // Processes all non-nginx containers with generic level extraction

  loki.process "generic" {
    forward_to = argument.loki_receiver.value

    // Drop nginx logs (handled by nginx processor)
    stage.match {
      selector = "{technology=\"nginx\"}"
      action   = "drop"
    }

    // Extract log level from common patterns
    // Matches: level=info, level="info", "level":"info", [INFO], INFO:, etc.
    stage.regex {
      expression = "(?i)(?:level[=:\"]\\s*\"?(?P<level>\\w+)|\\[(?P<level_bracket>DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE)\\]|^(?P<level_prefix>DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE):)"
    }

    // Set detected_level from whichever capture group matched
    stage.template {
      source   = "detected_level"
      template = "{{ or .level .level_bracket .level_prefix \"\" }}"
    }

    // Normalize level values to lowercase
    stage.template {
      source   = "detected_level"
      template = "{{ .detected_level | ToLower }}"
    }

    // Normalize "warning" to "warn"
    stage.replace {
      expression = "warning"
      source     = "detected_level"
      replace    = "warn"
    }

    // Default to "info" if no level detected
    stage.template {
      source   = "level"
      template = "{{ if .detected_level }}{{ .detected_level }}{{ else }}info{{ end }}"
    }

    // Add level as label
    stage.labels {
      values = {
        level = "",
      }
    }
  }
}
