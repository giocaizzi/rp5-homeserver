// Discover Docker containers
discovery.docker "containers" {
  host = "unix:///var/run/docker.sock"
}

// Relabel Docker metadata to OTEL semantic attributes
// Fallback chain: custom labels > swarm labels > compose labels > container metadata
discovery.relabel "docker_labels" {
  targets = discovery.docker.containers.targets

  // service_name: container name -> compose service -> swarm service -> custom label
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "^/?(.+)$"
    target_label  = "service_name"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    regex         = "(.+)"
    target_label  = "service_name"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_swarm_service_name"]
    regex         = "(?:.+_)?(.+)"
    target_label  = "service_name"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_service"]
    regex         = "(.+)"
    target_label  = "service_name"
  }

  // environment from com.giocaizzi.env (default to production if not set)
  rule {
    target_label = "environment"
    replacement  = "production"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_env"]
    regex         = "(.+)"
    target_label  = "environment"
  }

  // tier from com.giocaizzi.tier
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_tier"]
    target_label  = "tier"
  }

  // component from com.giocaizzi.component
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_component"]
    target_label  = "component"
  }

  // role from com.giocaizzi.role
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_role"]
    target_label  = "role"
  }

  // version from com.giocaizzi.version (optional)
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_version"]
    regex         = "(.+)"
    target_label  = "version"
  }

  // instance from container ID (short form)
  rule {
    source_labels = ["__meta_docker_container_id"]
    regex         = "^(.{12}).*$"
    target_label  = "instance"
  }

  // host from container hostname
  rule {
    source_labels = ["__meta_docker_container_hostname"]
    target_label  = "host"
  }

  // namespace: compose project -> swarm stack -> custom label
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    regex         = "(.+)"
    target_label  = "namespace"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_stack_namespace"]
    regex         = "(.+)"
    target_label  = "namespace"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_namespace"]
    regex         = "(.+)"
    target_label  = "namespace"
  }
}

// Scrape logs from discovered containers
loki.source.docker "containers" {
  host       = "unix:///var/run/docker.sock"
  targets    = discovery.relabel.docker_labels.output
  forward_to = [loki.process.docker_logs.receiver]
}

// Process Docker logs
loki.process "docker_logs" {
  forward_to = [loki.write.default.receiver]

  stage.docker {}

  // Add source identifier for Docker pipeline
  stage.static_labels {
    values = {
      source = "docker",
    }
  }

  // Extract log level from common patterns
  // Matches: level=info, level="info", "level":"info", [INFO], INFO:, etc.
  stage.regex {
    expression = "(?i)(?:level[=:\"]\\s*\"?(?P<level>\\w+)|\\[(?P<level_bracket>DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE)\\]|^(?P<level_prefix>DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE):)"
  }

  // Set detected_level from whichever capture group matched
  stage.template {
    source   = "detected_level"
    template = "{{ or .level .level_bracket .level_prefix \"\" }}"
  }

  // Normalize level values to lowercase
  stage.template {
    source   = "detected_level"
    template = "{{ .detected_level | ToLower }}"
  }

  // Normalize "warning" to "warn"
  stage.replace {
    expression = "warning"
    source     = "detected_level"
    replace    = "warn"
  }

  // Default to "info" if no level detected
  stage.template {
    source   = "level"
    template = "{{ if .detected_level }}{{ .detected_level }}{{ else }}info{{ end }}"
  }

  // Add level as label
  stage.labels {
    values = {
      level = "",
    }
  }
}
