// =============================================================================
// DOCKER LOG COLLECTION PIPELINE
// =============================================================================
// Collects logs from Docker containers and enriches them with OTEL-aligned labels.
// Labels use OTEL semconv naming converted to underscore format.
//
// Label Schema (OTEL Semconv → Loki/Prometheus Label):
//   service.name              → service_name
//   service.namespace         → service_namespace
//   service.version           → service_version
//   service.instance.id       → service_instance_id
//   deployment.environment.name → deployment_environment_name
//   host.name                 → host_name
//
// Custom Labels (no OTEL equivalent):
//   tier, component, role, technology, source, level
// =============================================================================

// Discover Docker containers
discovery.docker "containers" {
  host = "unix:///var/run/docker.sock"
}

// Relabel Docker metadata to OTEL-aligned labels
// Fallback chain: custom labels > swarm labels > compose labels > container metadata
discovery.relabel "docker_labels" {
  targets = discovery.docker.containers.targets

  // ---------------------------------------------------------------------------
  // INDEXED LABELS (low cardinality - used for filtering)
  // ---------------------------------------------------------------------------

  // service_name: container name → compose service → swarm service → custom label
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "^/?(.+)$"
    target_label  = "service_name"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    regex         = "(.+)"
    target_label  = "service_name"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_swarm_service_name"]
    regex         = "(?:.+_)?(.+)"
    target_label  = "service_name"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_service"]
    regex         = "(.+)"
    target_label  = "service_name"
  }

  // service_namespace: compose project → swarm stack → custom label
  // Default: external (for containers without namespace)
  rule {
    target_label = "service_namespace"
    replacement  = "external"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    regex         = "(.+)"
    target_label  = "service_namespace"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_stack_namespace"]
    regex         = "(.+)"
    target_label  = "service_namespace"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_namespace"]
    regex         = "(.+)"
    target_label  = "service_namespace"
  }

  // deployment_environment_name: default production (OTEL: deployment.environment.name)
  rule {
    target_label = "deployment_environment_name"
    replacement  = "production"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_env"]
    regex         = "(.+)"
    target_label  = "deployment_environment_name"
  }

  // tier: core/extra (default: core)
  rule {
    target_label = "tier"
    replacement  = "core"
  }
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_tier"]
    regex         = "(.+)"
    target_label  = "tier"
  }

  // component: app/data/cache/worker/gateway/network/observability
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_component"]
    regex         = "(.+)"
    target_label  = "component"
  }

  // ---------------------------------------------------------------------------
  // METADATA LABELS (high cardinality - stored as structured metadata)
  // ---------------------------------------------------------------------------

  // service_instance_id: container ID (short form, 12 chars)
  rule {
    source_labels = ["__meta_docker_container_id"]
    regex         = "^(.{12}).*$"
    target_label  = "service_instance_id"
  }

  // service_version: from custom label (optional)
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_version"]
    regex         = "(.+)"
    target_label  = "service_version"
  }

  // host_name: container hostname
  rule {
    source_labels = ["__meta_docker_container_hostname"]
    target_label  = "host_name"
  }

  // role: specific function within component (free-form)
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_role"]
    regex         = "(.+)"
    target_label  = "role"
  }

  // technology: implementation technology (postgres, nginx, redis, etc.)
  rule {
    source_labels = ["__meta_docker_container_label_com_giocaizzi_technology"]
    regex         = "(.+)"
    target_label  = "technology"
  }
}

// Scrape logs from discovered containers
loki.source.docker "containers" {
  host       = "unix:///var/run/docker.sock"
  targets    = discovery.relabel.docker_labels.output
  forward_to = [loki.process.docker_logs.receiver]
}

// Process Docker logs
loki.process "docker_logs" {
  forward_to = [loki.write.default.receiver]

  stage.docker {}

  // Add source identifier for Docker pipeline
  stage.static_labels {
    values = {
      source = "docker",
    }
  }

  // Extract log level from common patterns
  // Matches: level=info, level="info", "level":"info", [INFO], INFO:, etc.
  stage.regex {
    expression = "(?i)(?:level[=:\"]\\s*\"?(?P<level>\\w+)|\\[(?P<level_bracket>DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE)\\]|^(?P<level_prefix>DEBUG|INFO|WARN|WARNING|ERROR|FATAL|TRACE):)"
  }

  // Set detected_level from whichever capture group matched
  stage.template {
    source   = "detected_level"
    template = "{{ or .level .level_bracket .level_prefix \"\" }}"
  }

  // Normalize level values to lowercase
  stage.template {
    source   = "detected_level"
    template = "{{ .detected_level | ToLower }}"
  }

  // Normalize "warning" to "warn"
  stage.replace {
    expression = "warning"
    source     = "detected_level"
    replace    = "warn"
  }

  // Default to "info" if no level detected
  stage.template {
    source   = "level"
    template = "{{ if .detected_level }}{{ .detected_level }}{{ else }}info{{ end }}"
  }

  // Add level as label
  stage.labels {
    values = {
      level = "",
    }
  }
}
